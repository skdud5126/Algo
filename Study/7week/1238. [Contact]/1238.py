# SWEA 1238. [Contact]

'''
비상연락망과 연락을 시작하는 당번에 대한 정보가 주어질 때,

가장 나중에 연락을 받게 되는 사람 중 번호가 가장 큰 사람을 구하는 함수를 작성하시오.

※ 3, 6, 11, 22번은 시간이 지나도 연락을 받지 못한다.

[제약 사항]

연락 인원은 최대 100명이며, 부여될 수 있는 번호는 1이상, 100이하이다.

단, 예시에서 5번이 존재하지 않듯이 중간 중간에 비어있는 번호가 있을 수 있다.

한 명의 사람이 다수의 사람에게 연락이 가능한 경우 항상 다자 간 통화를 통해 동시에 전달한다.

연락이 퍼지는 속도는 항상 일정하다 (전화를 받은 사람이 다음사람에게 전화를 거는 속도는 동일).

비상연락망 정보는 사전에 공유되며 한 번 연락을 받은 사람에게 다시 연락을 하는 일은 없다.

예시에서의 3, 6, 11, 22번과 같이 연락을 받을 수 없는 사람도 존재할 수 있다.

[입력]

10개의 테스트 케이스가 주어진다.

각 테스트 케이스의 첫 번째 줄에는 입력 받는 데이터의 길이와 시작점이 주어진다.

그 다음 줄에 입력받는 데이터는 {from, to, from, to, …} 의 순서로 해석되며 예시의 경우는 {2, 7, 11, 6, 6, 2, 2, 15, 15, 4, 4, 2, 4, 10, 7, 1. [가장 먼 노드], 1. [가장 먼 노드], 7, 1. [가장 먼 노드], 8, 1. [가장 먼 노드], 17, 3, 22}와 같다.

그런데 순서에는 상관이 없으므로 다음과 같이 주어진 인풋도 동일한 비상연락망을 나타낸다 (같은 비상연락망을 표현하는 다양한 인풋이 존재 가능하다).

{1. [가장 먼 노드], 17, 3, 22, 1. [가장 먼 노드], 8, 1. [가장 먼 노드], 7, 7, 1. [가장 먼 노드], 2, 7, 2, 15, 15, 4, 6, 2, 11, 6, 4, 10, 4, 2}

다음과 같이 동일한 {from, to}쌍이 여러 번 반복되는 경우도 있으며, 한 번 기록된 경우와 여러 번 기록된 경우의 차이는 없다.

{1. [가장 먼 노드], 17, 1. [가장 먼 노드], 17, 1. [가장 먼 노드], 17, 3, 22, 1. [가장 먼 노드], 8, 1. [가장 먼 노드], 7, 7, 1. [가장 먼 노드], 2, 7, 2, 15, 15, 4, 6, 2, 11, 6, 4, 10, 11, 6, 4, 2}

[출력]

#부호와 함께 테스트 케이스의 번호를 출력하고, 공백 문자 후 테스트 케이스에 대한 답을 출력한다.

'''

# 24 2
# 100 17 39 22 100 8 100 7 7 100 2 7 2 15 15 4 6 2 11 6 4 10 4 2

def bfs(start, visited):
    visited[start] = 1  # 연락함
    queue = [start]   # 시작 점 추가

    while queue:  # 큐가 빌 때까지 진행
        v = queue.pop(0)
        for ele in adjL[v]:   # 큐 pop한 요소와 연결된 노드
            if not visited[ele]:  # 연락하지 않았으면
                visited[ele] = visited[v] + 1   # 연락순서  + 1. [가장 먼 노드]
                queue.append(ele)

T = 10

for case in range(1, T+1):
    length, start = map(int,input().split())  # length: 데이터 길이 / start : 시작점
    contact_num = list(map(int,input().split()))

    adjL = [set() for _ in range(101)]  # 제약사항 ㅣ 동일한 {from, to}쌍이 여러 번 반복되는 경우도 있으며
    visited = [0] * 101  # 번호는 1이상 100이하이기에 연락했는지 체크용 visited

    for i in range(length//2):
        adjL[contact_num[i*2]].add(contact_num[i*2+1])

    bfs(start,visited)

    visited.reverse()
    # 연락을 다 돌린후 연락 순서가 젤 큰게 마지막 연락 받았다는 의미 뒤집었을 때 max 마지막 인덱스 가져오기 위함

    print(f'#{case} {100-visited.index(max(visited))}')