# SWEA. 진기의 최고급 붕어빵

'''
진기는 붕어빵 가게를 운영하고 있다.

그는 무조건 예약제로만 손님을 받으며, 예약을 하려는 손님들은 진기의 까다로운 자격 검증에서 합격해야만 붕어빵을 맛 볼 자격을 얻는다.

그래서 오늘은 N명의 사람이 자격을 얻었다.

진기는 0초부터 붕어빵을 만들기 시작하며, M초의 시간을 들이면 K개의 붕어빵을 만들 수 있다.

서빙은 진기가 하는 것이 아니기 때문에, 붕어빵이 완성되면 어떤 시간 지연도 없이 다음 붕어빵 만들기를 시작할 수 있다.

0초 이후에 손님들이 언제 도착하는지 주어지면, 모든 손님들에게 기다리는 시간없이 붕어빵을 제공할 수 있는지 판별하는 프로그램을 작성하라.


[입력]

첫 번째 줄에 테스트 케이스의 수 T가 주어진다.

각 테스트 케이스의 첫 번째 줄에는 세 자연수 N, M, K(1 ≤ N, M, K ≤ 100)가 공백으로 구분되어 주어진다.

두 번째 줄에는 N개의 정수가 공백으로 구분되어 주어지며,

각 정수는 각 사람이 언제 도착하는지를 초 단위로 나타낸다. 각 수는 0이상 11,111이하이다.


[출력]

각 테스트 케이스마다 ‘#x’(x는 테스트케이스 번호를 의미하며 1부터 시작한다)를 출력하고,

모든 손님에 대해 기다리는 시간이 없이 붕어빵을 제공할 수 있으면 “Possible”을, 아니라면 “Impossible”을 출력한다.


[예제 풀이]

2번째 테스트 케이스의 경우, 2초가 지날 때마다 붕어빵을 2개씩 만들 수 있다.

하지만 손님 1명은 1초에 도착하므로 이 손님에게는 붕어빵을 바로 제공할 수 없다.

따라서 결과값으로 Impossible 출력한다.

'''

T = int(input())  # 테스트 케이스 수 T

for case in range(1, T+1):
    N, M, K = map(int,input().split())  # N 명의 손님 / M초마다 K개의 붕어빵 생성
    arrive_time = list(map(int,input().split()))  # 손님 도착 시간

    boongs = [0] * (max(arrive_time)+1)   # 붕어빵 만든 현황 표시 위함
    res = 'Possible'

    for i in range(1, len(boongs)):   # [0, 0, 2, 2, 4]
        boongs[i] = i//M * K

    for customer in arrive_time:
        for i in range(customer,len(boongs)):  # 도착시간때마다 손님이 한개씩 사갔다고 가정하여 한개씩 뺴줌
            boongs[i]+= -1

    for arrive in arrive_time:
        if boongs[arrive] < 0:   # 붕어빵 현황에 0보다 작으면 손님 구매 실패했음
            res = 'Impossible'
            break

    print(f'#{case} {res}')

