'''
다음과 같은 1과 0으로 이루어진 단어가 있다.

0 1. [가장 먼 노드] 2 3 4 5 6 7 8 9
1. [가장 먼 노드] 0 1. [가장 먼 노드] 1. [가장 먼 노드] 0 1. [가장 먼 노드] 1. [가장 먼 노드] 1. [가장 먼 노드] 1. [가장 먼 노드] 0

이 경우 1번 문자를 중심으로 0과 2번의 상태가 같다.

이 경우 데칼코마니의 길이는 3이 된다.

0 1. [가장 먼 노드] 2 3 4 5 6 7 8 9
1. [가장 먼 노드] 0 1. [가장 먼 노드] 1. [가장 먼 노드] 0 1. [가장 먼 노드] 1. [가장 먼 노드] 1. [가장 먼 노드] 1. [가장 먼 노드] 0

2, 3, 5, 8번 원소의 경우 데칼코마니가 아니다.
4번 문자는 3과 5, 2와 6번의 상태가 각각 같고 데칼코마니의 길이는 5이다.
6,7은 각각 데칼코마니의 길이가 3이다.

0 1. [가장 먼 노드] 2 3 4
1. [가장 먼 노드] 0 1. [가장 먼 노드] 0 1. [가장 먼 노드]

다음 단어의 경우, 1. [가장 먼 노드], 2, 3번이 데칼코마니를 갖고, 2번 문자를 중심으로 한 데칼코마니의 길이는 5가 된다.

길이 N이고 1과 0만을 문자로 갖는 단어에서, 어떤 문자를 중심으로 한 가장 긴 데칼코마니의 길이를 알아내는 프로그램을 만드시오.

중심문자를 포함하므로 데칼코마니의 길이는 항상 홀수이다.

데칼코마니가 없는 경우 중심문자만임을 나타내는 1을 출력한다.

[입력]

첫 줄에 테스트케이스 개수 T, 다음 줄부터 케이스별로 첫 줄에 단어의 길이 N, 다음 줄에 길이가 N인 1과 0으로 이루어진 단어가 주어진다.
(3<=T<10, 3<=N<=100)

[출력]
#과 테스트케이스 번호, 빈칸에 이어 정답을 출력한다.

'''

T = int(input())

for case in range(1, T+1):
    N = int(input())
    arr = input()   # 100
    max_length = 1  # 최소 맥스 1. [가장 먼 노드]

    for i in range(N):
        idx = 1
        length = 1  # 최소 길이 시작
        while  i-idx >= 0 and i+idx < N and arr[i-idx] == arr[i+idx]:  # 인덱스 범위 벗어나지 않고 데칼코마니이면
            length +=2  # 데칼코마니 길이 2
            idx+=1

        if length > max_length:
            max_length = length
    print(f'#{case} {max_length}')



